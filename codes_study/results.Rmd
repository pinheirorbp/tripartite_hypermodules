---
title: "The hypermodular structure of tripartite ecological networks"
author: "Rafael Pinheiro, Luciano Cagnolo, Guadalupe Peralta and Thomas Lewinsohn"
date: "`r Sys.Date()`"
output:
  pdf_document:
    toc: true
    toc_depth: 2
  html_document:
    toc: true
    toc_depth: '2'
    df_print: paged
---


\newpage
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
options(digits=2)
options(scipen=999)
```

<!-- Important Comments -->
<!-- NETa = BN (A-B) / NETb = BN (B-C) -->
<!-- l1,l2,l3 = partitions A,B,C -->

```{r include=FALSE}
####
datasets_log=c(4,6,7,8)
datasets_rounded=c(11)
datasets_reescale=c(15,17)
####
tab1=list(dataset=character(), binary=character(), OPT=numeric(), congruence=numeric(), Ha=numeric(), Hb=numeric(), H=numeric(),  s1=numeric(), s2=numeric(), s3=numeric(), s2a=numeric(), s2b=numeric(), l1=numeric(), l2=numeric(), l3=numeric(), SF=character(), p1=numeric(), p2=numeric(), Ntopology=numeric(), Nnull1=numeric(), Nnull2=numeric(), NETa_mod=numeric(), NETa_mod_p=numeric(), NETb_mod=numeric(), NETb_mod_p=numeric(), NETa_NestSM=numeric(), NETa_NestSM_p=numeric(), NETb_NestSM=numeric(), NETb_NestSM_p=numeric(), NETa_topology=character(), NETb_topology=character(), NETa_sum=numeric(), NETb_sum=numeric(), NETa_max=numeric(), NETa_min=numeric(), NETb_max=numeric(), NETb_min=numeric(), log=logical(), rounded=logical(), reescale=logical(), N1_00=numeric(), N1_95=numeric(), N1_mean=numeric(),N2_00_Cadj=numeric(), N2_95_Cadj=numeric(), N2_mean_Cadj=numeric(),N2_00_C=numeric(), N2_95_C=numeric(), N2_mean_C=numeric()) 
library(stringr)
library(xlsx)
```

# README

This document describes step-by-step the results of the study "The hypermodular structure of tripartite ecological networks".

The PDF was generated by a R Markdown and other files, available at: https://github.com/pinheirorbp/tripartite_hypermodules. Codes to reproduce all analysis are also provided.


\newpage
```{r, results='asis', fig.dim= c(6,3)}
file.sources = list.files(path = "files_results/",pattern = "dataset_")
SUB=sub(".*_",x=file.sources,"")
datasetIDs=sort(as.numeric(sub(".RData",x=SUB,"")))
cat("\\section{Datasets}")
for (DS in datasetIDs){
  # Header
  load(paste("files_results/dataset_",DS,".RData",sep=""))
  REM=ifelse(sum(is.element(rownames(NETa),rownames(NETb)))<7,"-REMOVED-","")
  B=max(NETa)==1|max(NETb)==1
  cat("\\subsection{Dataset",DS,": ",dataset_info$name,REM,"}")
  if(B){cat("\\paragraph{ BINARY DATASET}")}
  # NETa
  cat("\\subsubsection{","Topology BN (A-B): ",dataset_info$level1, " - ",  dataset_info$level2,"}")
  cat("\\paragraph{\\underline{Modularity}}")
  cat("\\paragraph{}..")
  cat("\\newline{Observed Modularity:}",MODNETa$modularity)
  cat("\\newline{Number of Modules:}",length(unique(MODNETa$Row_labels)))
  if(!B){
  cat("\\paragraph{}Comparison between observed modularity (blue line) and proportional null model (density in black)")
  cat("\\paragraph{}")
  plot(ylab="density",density(modnull_NETa), xlim=c(0,1), lwd=2, main=NA, xlab="modularity")
  abline(v= MODNETa$modularity, col="blue")
  cat("\\paragraph{}..")
  Ntopology=length(modnull_NETa)
  cat("\\newline{}Number of Matrices in Null Model:",Ntopology)
  NETa_mod_p=sum(modnull_NETa>=MODNETa$modularity)/length(modnull_NETa)
  cat("\\newline{P-Value:}",NETa_mod_p)
  }
  if (B){
    Ntopology=0
  NETa_mod_p=NA
  }
  cat("\\paragraph{\\underline{Low-level nestedness}}")
  cat("\\paragraph{}..")
  NETa_Nest=ifelse(!B,Nest_SMDM_NETa$WNODAmatrix, Nest_SMDM_NETa$NODFmatrix)
  NETa_NestDM=ifelse(!B,Nest_SMDM_NETa$WNODA_DM_matrix, Nest_SMDM_NETa$NODF_DM_matrix)
  NETa_NestSM=ifelse(!B,Nest_SMDM_NETa$WNODA_SM_matrix, Nest_SMDM_NETa$NODF_SM_matrix)
  cat("\\newline{Nestedness in the entire matrix:}",NETa_Nest)
  cat("\\newline{Nestedness between species in the same module:}",NETa_NestSM)
  cat("\\newline{","Nestedness between species in different modules:}",NETa_NestDM)
  if (!B){
  cat("\\paragraph{}Comparison between observed WNODA SM (blue line) and proportional null model (density in black)")
  cat("\\paragraph{}")
  plot(xlab="WNODA SM", ylab="density", density(NestSMnull_NETa), xlim=c(0,100), lwd=2, main=NA)
  abline(v= Nest_SMDM_NETa$WNODA_SM_matrix, col="blue")
  cat("\\paragraph{}..")
  cat("\\newline{Number of Matrices in Null Model:}",Ntopology)
  NETa_NestSM_p=sum(NestSMnull_NETa>=Nest_SMDM_NETa$WNODA_SM_matrix)/length(NestSMnull_NETa)
  cat("\\newline{P-Value:}",NETa_NestSM_p)
  if(NETa_mod_p>=.05){NETa_topology= "non-modular"} else{
    if(NETa_NestSM_p>=.05){NETa_topology="purely modular"}
    else{NETa_topology="compound"
    }}
  cat("\\paragraph{\\underline{CONCLUSION:}} BN (A-B) has a ", NETa_topology, " topology")
  }
  if (B){
    NETa_Nest_SM_p=NA
    NETa_topology=NA
    }
  # NETb
  cat("\\subsubsection{","Topology BN (B-C): ",dataset_info$level2, " - ",  dataset_info$level3,"}")
  cat("\\paragraph{\\underline{Modularity}}")
  cat("\\paragraph{}..")
  cat("\\newline{Observed Modularity:}",MODNETb$modularity)
  cat("\\newline{Number of Modules:}",length(unique(MODNETb$Row_labels)))
  if(!B){
  cat("\\paragraph{}Comparison between observed modularity (blue line) and proportional null model (density in black)")
  cat("\\paragraph{}")
  plot(ylab="density",density(modnull_NETb), xlim=c(0,1), lwd=2, main=NA, xlab="modularity")
  abline(v= MODNETb$modularity, col="blue")
  cat("\\paragraph{}..")
  cat("\\newline{}Number of Matrices in Null Model:",Ntopology)
  NETb_mod_p=sum(modnull_NETb>=MODNETb$modularity)/length(modnull_NETb)
  cat("\\newline{P-Value:}",NETb_mod_p)
  }
  if (B){
  NETb_mod_p=NA
  }
  cat("\\paragraph{\\underline{Low-level nestedness}}")
  cat("\\paragraph{}..")
  NETb_Nest=ifelse(!B,Nest_SMDM_NETb$WNODAmatrix, Nest_SMDM_NETb$NODFmatrix)
  NETb_NestDM=ifelse(!B,Nest_SMDM_NETb$WNODA_DM_matrix, Nest_SMDM_NETb$NODF_DM_matrix)
  NETb_NestSM=ifelse(!B,Nest_SMDM_NETb$WNODA_SM_matrix, Nest_SMDM_NETb$NODF_SM_matrix)
  cat("\\newline{Nestedness in the entire matrix}",NETb_Nest)
  cat("\\newline{Nestedness between species in the same module}",NETb_NestSM)
  cat("\\newline{","Nestedness between species in different modules}",NETb_NestDM)
  if (!B){
  cat("\\paragraph{}Comparison between observed WNODA SM (blue line) and proportional null model (density in black)")
  cat("\\paragraph{}")
  plot(xlab="WNODA SM", ylab="density", density(NestSMnull_NETb), xlim=c(0,100), lwd=2, main=NA)
  abline(v= Nest_SMDM_NETb$WNODA_SM_matrix, col="blue")
  cat("\\paragraph{}..")
  cat("\\newline{Number of Matrices in Null Model:}",Ntopology)
  NETb_NestSM_p=sum(NestSMnull_NETb>=Nest_SMDM_NETb$WNODA_SM_matrix)/length(NestSMnull_NETb)
  cat("\\newline{P-Value:}",NETb_NestSM_p)
  if(NETb_mod_p>=.05){NETb_topology= "non-modular"} else{
    if(NETb_NestSM_p>=.05){NETb_topology="purely modular"}
    else{NETb_topology="compound"
    }}
  cat("\\paragraph{\\underline{CONCLUSION:}} BN (B-C) has a ", NETb_topology, " topology")
  }
  if (B){
    NETb_Nest_SM_p=NA
    NETb_topology=NA
    }
  cat("\\subsubsection{Bipartite Networks and Intercept}")
  cat("\\paragraph{}..")
  cat("\\newline{BN (A-B) Specialization (H2')}",NETdata$NETa_H2)
  cat("\\newline{BN (A-B) Connectance}",NETdata$NETa_connectance)
  cat("\\newline{BN (B-C) Specialization (H2')}",NETdata$NETb_H2)
  cat("\\newline{BN (B-C) Connectance}",NETdata$NETb_connectance)
  cat("\\newline{",dataset_info$level1," richness in BN (A-B):}",ncol(NETa))  
  cat("\\newline{",dataset_info$level2," richness in BN (A-B):}",nrow(NETa))
  cat("\\newline{",dataset_info$level2," richness in BN (B-C):}",nrow(NETb))
  cat("\\newline{",dataset_info$level3," richness in BN (B-C):}",ncol(NETb))
  cat("\\newline{ Richness of shared ",dataset_info$level2,"s:}",length(unique(c(rownames(NETa)[is.element(rownames(NETa),rownames(NETb))],rownames(NETb)))),sep = "")
  cat("\\newline{Number of modules in BN (A-B)}",length(unique(MODNETa$Row_labels)))
  cat("\\newline{Number of modules in BN (B-C)}",length(unique(MODNETb$Row_labels)))
  cat("\\newline{Number of modules in BN (A-B) (only for shared species)}",length(unique(MODNETa$Row_labels[is.element(rownames(NETa),rownames(NETb))])))
  cat("\\newline{Number of modules in BN (B-C) (only for shared species)}",length(unique(MODNETb$Row_labels[is.element(rownames(NETb),rownames(NETa))])))

  cat("\\subsubsection{Hipermodule Congruence}")
  cat("\\paragraph{Optmization procedure}")
  cat("\\paragraph{}..")
plot(y=CONGRUENCE$OPT[seq.int(from=500, to=length(CONGRUENCE$OPT), by=100)],
     x=seq.int(from=500, to=length(CONGRUENCE$OPT), by=100),ylim=c(-.3,1),
     pch=16, cex=.5, ylab="adjusted congruence", xlab="iteration")
cat("\\paragraph{}")
plot(y=CONGRUENCE$congruence[seq.int(from=500, to=length(CONGRUENCE$OPT), by=100)],
     x=seq.int(from=500, to=length(CONGRUENCE$OPT), by=100),ylim=c(0,1),
     pch=16, cex=.5, ylab="realized congruence", xlab="iteration")
cat("\\paragraph{}..")
cat("\\newline{Adjusted Congruence: }",CONGRUENCE$finalOPT)
cat("\\newline{Realized Congruence: }",CONGRUENCE$finalcongruence)
cat("\\newline{Hypermodularity: }",hypermod$overall)

cat("\\subsubsection{Null Model 1}")

BASE=CONGRUENCE$finalcongruence-CONGRUENCE$finalOPT
plot(NA, xlim=c(0,1), ylim=c(0,.5),axes=F, xlab="congruence", ylab=NA)
axis(1, lwd=0)
lines(x=c(0,1), y=c(.2,.2))
points(x=CONGRUENCE$finalcongruence, y=.2, col="blue", pch=16, cex=2)
points(x=BASE, y=.2, col="black", pch=16, cex=2)
lines(x=c(BASE,CONGRUENCE$finalcongruence), y=c(.3,.3),lty=2, lwd=2)
lines(x=c(BASE,BASE), y=c(.27,.33),lwd=2)
lines(x=c(CONGRUENCE$finalcongruence,CONGRUENCE$finalcongruence), y=c(.27,.33),lwd=2)
text(paste("C.adj =",round(CONGRUENCE$finalcongruence-BASE,digits = 2)),
  x=mean(c(CONGRUENCE$finalcongruence,BASE)),y=.35, font=2, pos=3)
N1_00=min(nullCongruence$Nullcongruence)
N1_95=quantile(nullCongruence$Nullcongruence,.95)
N1_mean=mean(nullCongruence$Nullcongruence)
lines(x=c(N1_00,N1_95), y=c(.1,.1),lty=1, lwd=2, col="red")
lines(x=c(N1_00,N1_00), y=c(.07,.13),lwd=2, col="red")
lines(x=c(N1_95,N1_95), y=c(.07,.13),lwd=2, col="red")
points(x=N1_mean,y=.1,pch=16,col="red",cex=1)
cat("\\newline{}","Blue point: realized congruence; Black point: baseline congruence; Red interval: .95 CI based on the null model.")
cat("\\paragraph{} ..")
Nnull1=length(nullCongruence$Nullcongruence)
cat("\\newline{Number of Matrices in Null Model 1:}",Nnull1)
PvalueNull1=sum(nullCongruence$Nullcongruence>=CONGRUENCE$finalcongruence)/
  length(nullCongruence$Nullcongruence)
cat("\\newline{P-Value:}",PvalueNull1)

cat("\\subsubsection{Null Model 2}")
cat("\\paragraph{}Comparison between observed adjusted congruence (blue line) and Null Model 2 (density in black)")
cat("\\paragraph{}")
plot(xlab=NA,ylab="density",density(nullCongruence2$NullOPT), xlim=c(0,1), lwd=2, main="C.adj")
abline(v= CONGRUENCE$finalOPT, col="blue")
cat("\\paragraph{} ..")
Nnull2=length(nullCongruence2$NullOPT)
cat("\\newline{Number of Matrices in Null Model 2:}",Nnull2)
PvalueNull2=sum(nullCongruence2$NullOPT>=CONGRUENCE$finalOPT)/
  length(nullCongruence2$NullOPT)
cat("\\newline{P-Value:}",PvalueNull2)
N2_00_Cadj=min(nullCongruence2$NullOPT)
N2_95_Cadj=quantile(nullCongruence2$NullOPT,.95)
N2_mean_Cadj=mean(nullCongruence2$NullOPT)
N2_00_C=min(nullCongruence2$Nullcongruence)
N2_95_C=quantile(nullCongruence2$Nullcongruence,.95)
N2_mean_C=mean(nullCongruence2$Nullcongruence)
### summary

levelcode=data.frame(name=c("Herbivore","herbivore","pulp.feeder","Plant","Parasitoid", "Seed disperser", "Parasite","Defender","defender", "Pollinator", "Plant defender", "predator","Predator", "enemy","Enemy","Seed predator", "seed predator", "Mycorrhiza"), code=c("He","He","He","Pl","Pa1", "SD","Pa2","De","De", "Po","De", "Pr","Pr", "En","En","SP","SP","My"))
level1=levelcode$code[match(dataset_info$level1,levelcode$name)]
level2=levelcode$code[match(dataset_info$level2,levelcode$name)]
level3=levelcode$code[match(dataset_info$level3,levelcode$name)]
topologycode=data.frame(name=c("non-modular","purely modular","compound"), code=c("N","M","C"))
TOPa=topologycode$code[match(NETa_topology,topologycode$name)]
TOPb=topologycode$code[match(NETb_topology,topologycode$name)]
##
tab1$dataset=c(tab1$dataset,DS)
tab1$OPT=c(tab1$OPT,CONGRUENCE$finalOPT)
tab1$congruence=c(tab1$congruence,CONGRUENCE$finalcongruence)
tab1$s2=c(tab1$s2,sum(is.element(rownames(NETa),rownames(NETb))))
tab1$s1=c(tab1$s1,ncol(NETa))
tab1$s3=c(tab1$s3,ncol(NETb))
tab1$s2a=c(tab1$s2a,nrow(NETa))
tab1$s2b=c(tab1$s2b,nrow(NETb))
tab1$l1=c(tab1$l1,level1)
tab1$l2=c(tab1$l2,level2)
tab1$l3=c(tab1$l3,level3)
tab1$SF=c(tab1$SF,ifelse(level1=="Pl","S","F"))
tab1$p1=c(tab1$p1,ifelse(PvalueNull1<.05,paste(round(PvalueNull1,digits = 2),"*"),paste(round(PvalueNull1,digits = 2)," ")))
tab1$p2=c(tab1$p2,ifelse(PvalueNull2<.05,paste(round(PvalueNull2,digits = 2),"*"),paste(round(PvalueNull2,digits = 2)," ")))
tab1$Ntopology=c(tab1$Ntopology,Ntopology)
tab1$Nnull1=c(tab1$Nnull1,Nnull1)
tab1$Nnull2=c(tab1$Nnull2,Nnull2)
tab1$binary=c(tab1$binary,ifelse(B,"B","W"))
tab1$NETa_topology=c(tab1$NETa_topology,TOPa)
tab1$NETb_topology=c(tab1$NETb_topology,TOPb)
tab1$NETa_mod=c(tab1$NETa_mod,MODNETa$modularity)
tab1$NETb_mod=c(tab1$NETb_mod,MODNETb$modularity)
tab1$NETa_mod_p=c(tab1$NETa_mod_p,NETa_mod_p)
tab1$NETb_mod_p=c(tab1$NETb_mod_p,NETb_mod_p)
tab1$NETa_NestSM=c(tab1$NETa_NestSM,NETa_NestSM)
tab1$NETb_NestSM=c(tab1$NETb_NestSM,NETb_NestSM)
tab1$NETa_NestSM_p=c(tab1$NETa_NestSM_p,NETa_NestSM_p)
tab1$NETb_NestSM_p=c(tab1$NETb_NestSM_p,NETb_NestSM_p)
tab1$NETa_sum=c(tab1$NETa_sum, sum(NETa))
tab1$NETb_sum=c(tab1$NETb_sum, sum(NETb))
tab1$H=c(tab1$H,hypermod$overall)
tab1$Ha=c(tab1$Ha,hypermod$NETa)
tab1$Hb=c(tab1$Hb,hypermod$NETb)
tab1$NETa_max=c(tab1$NETa_max,max(NETa))
tab1$NETb_max=c(tab1$NETb_max,max(NETb))
tab1$NETa_min=c(tab1$NETa_min,min(NETa[NETa!=0]))
tab1$NETb_min=c(tab1$NETb_min,min(NETb[NETb!=0]))
tab1$log=c(tab1$log,DS%in%datasets_log)
tab1$rounded=c(tab1$rounded,DS%in%datasets_rounded)
tab1$reescale=c(tab1$reescale,DS%in%datasets_reescale)
tab1$N1_00=c(tab1$N1_00, N1_00)
tab1$N1_95=c(tab1$N1_95, N1_95)
tab1$N1_mean=c(tab1$N1_mean, N1_mean)
tab1$N2_00_Cadj=c(tab1$N2_00_Cadj, N2_00_Cadj)
tab1$N2_95_Cadj=c(tab1$N2_95_Cadj, N2_95_Cadj)
tab1$N2_mean_Cadj=c(tab1$N2_mean_Cadj, N2_mean_Cadj)
tab1$N2_00_C=c(tab1$N2_00_C, N2_00_C)
tab1$N2_95_C=c(tab1$N2_95_C, N2_95_C)
tab1$N2_mean_C=c(tab1$N2_mean_C, N2_mean_C)
}
```

```{r, include=F}
# x0 = Dataset Info
x0= data.frame(
  A=tab1$l1,
  B=tab1$l2,
  C=tab1$l3,
  nA=tab1$s1,
  nB_con=tab1$s2,
  nC=tab1$s3,
  nB_AB=tab1$s2a,
  nB_BC=tab1$s2b,
  dt= tab1$binary,
  tr= "",
  row.names = paste ("dataset",tab1$dataset)
  )

x0$tr[tab1$log]=2
x0$tr[tab1$reescale]=3
x0$tr[tab1$rounded]=1

# x1 = Bipartite structure
x1= data.frame(
  dt= tab1$binary,
  tr= "",
  M_AB= tab1$NETa_mod,
  pM_AB= tab1$NETa_mod_p,
  N_AB= tab1$NETa_NestSM,
  pN_AB= tab1$NETa_NestSM_p,
  T_AB= tab1$NETa_topology,
  M_BC= tab1$NETb_mod,
  pM_BC= tab1$NETb_mod_p,
  N_BC= tab1$NETb_NestSM,
  pN_BC= tab1$NETb_NestSM_p,
  T_BC= tab1$NETb_topology,
  row.names = paste ("dataset",tab1$dataset)
  )
x1$tr[tab1$log]=2
x1$tr[tab1$reescale]=3
x1$tr[tab1$rounded]=1
x1[is.na(x1)]="-"

x1extra=data.frame(
  row.names = paste ("dataset",tab1$dataset),
  sum_NETa = tab1$NETa_sum,
  sum_NETb = tab1$NETb_sum
)

# x2 = Tripartite structure
x2= data.frame(
  A=tab1$l1,
  B=tab1$l2,
  C=tab1$l3,
  SF=tab1$SF,
  C.adj=tab1$OPT,
  C.r=tab1$congruence,
  H=tab1$H,
  p1=tab1$p1,
  p2=tab1$p2,
  row.names = paste ("dataset",tab1$dataset)
  )
x2extra=data.frame(
  row.names = paste ("dataset",tab1$dataset),
  N1_00=tab1$N1_00,
  N1_95=tab1$N1_95,
  N1_mean=tab1$N1_mean,
  N2_00_Cadj=tab1$N2_00_Cadj,
  N2_95_Cadj=tab1$N2_95_Cadj,
  N2_mean_Cadj=tab1$N2_mean_Cadj,
  N2_00_Cr=tab1$N2_00_C,
  N2_95_Cr=tab1$N2_95_C,
  N2_mean_Cr=tab1$N2_mean_C
  )
##
resultstable=cbind(dataset=tab1$dataset,x0,x1,x1extra,x2, x2extra)
save(resultstable, file="files_results/datasets.RData")
write.xlsx(resultstable, file="results.xlsx", sheetName = "datasets")
```

# Summary of null model analysis
## Null Model 1

```{r, fig.dim= c(6,12)}
par(mar=c(3,3,3,5))
t2=resultstable
t2=t2[order(t2$nB_con),]
plot(NA, xlim=c(-0.1,1), ylim=c(0,(nrow(t2)+2)*.1),axes=F, xlab=NA, ylab=NA)
axis(1, lwd=1,pos = 0)
mtext("Null Model 1", side = 3, line=0, font = 2)
mtext("realized congruence", side = 1, line=0.5)
mtext("nB_con", side = 2, line=0, las=2)
j=t2$nB_con[1]
for (i in 1:nrow(t2)){
  Ys=.1*i
  lines(x=c(t2$N1_00[i],t2$N1_95[i]), y=c(Ys,Ys), lwd=2, col="darkred")
  lines(x=c(t2$N1_00[i],t2$N1_00[i]), y=c(Ys+.03,Ys-.03),lwd=2, col="darkred")
  lines(x=c(t2$N1_95[i],t2$N1_95[i]), y=c(Ys+.03,Ys-.03),lwd=2, col="darkred")
  points(x=t2$N1_mean[i],y=Ys,pch=16,col="darkred",cex=1)
  points(x=t2$C.r[i], y=Ys, pch=16)
  if(i==1){text(x=-.01, y=0.05, t2$nB_con[i],pos = 2)}
  if(t2$nB_con[i]!=j){
    lines(x=c(0,1), y=c(Ys-.05, Ys-.05), lty=2)
    text(x=-.01, y=Ys, t2$nB_con[i],pos = 2)
    j=t2$nB_con[i]
  }
   mtext(rownames(t2)[i], side = 4, line=0, las=2, at=Ys)
}
```

The inspection of these preliminary results reveals that in datasets with too few connector species, the distribution of congruence in the null model usually encompasses all the space for realized congruence (up to 1). Therefore, even a TN with maximal congruence would not be distinguished from the null expectation.

This complete lack of power is prevalent in datasets with less than 7 connector species, with only one exception (dataset 47), but does not occur for the remaining datasets. 

These findings led to the selection criteria of at least 7 connector species for datasets, which we follow hereafter.


## Null Model 2

```{r, fig.dim= c(6,12)}
t2=t2[t2$nB_con>6,]
par(mar=c(3,3,3,5))
plot(NA, xlim=c(-0.1,1), ylim=c(0,(nrow(t2)+2)*.1),axes=F, xlab=NA, ylab=NA)
axis(1, lwd=1,pos = 0)
mtext("Null Model 2", side = 3, line=0, font = 2)
mtext("adjusted congruence", side = 1, line=0.5)
mtext("nB_con", side = 2, line=0, las=2)
j=t2$nB_con[1]
for (i in 1:nrow(t2)){
  Ys=.1*i
  lines(x=c(t2$N2_00_Cadj[i],t2$N2_95_Cadj[i]), y=c(Ys,Ys), lwd=2, col="darkred")
  lines(x=c(t2$N2_00_Cadj[i],t2$N2_00_Cadj[i]), y=c(Ys+.03,Ys-.03),lwd=2, col="darkred")
  lines(x=c(t2$N2_95_Cadj[i],t2$N2_95_Cadj[i]), y=c(Ys+.03,Ys-.03),lwd=2, col="darkred")
  points(x=t2$N2_mean_Cadj[i],y=Ys,pch=16,col="darkred",cex=1)
  points(x=t2$C.adj[i], y=Ys, pch=16)
  if(i==1){text(x=-.01, y=0.05, t2$nB_con[i],pos = 2)}
  if(t2$nB_con[i]!=j){
    lines(x=c(0,1), y=c(Ys-.05, Ys-.05), lty=2)
    text(x=-.01, y=Ys, t2$nB_con[i],pos = 2)
    j=t2$nB_con[i]
  }
   mtext(rownames(t2)[i], side = 4, line=0, las=2, at=Ys)
}
```

# Summary of structural analyses
## Datasets Info

```{r}
x0_2= x0[x0$nB_con>6, ]
knitr::kable(x0_2, digits=2)
```

Only datasets with nB_con>=7. A,B,C= partitions; nA= number of species in partition A; nB_con= number of connector species; nC= number of species in partition C; nB_AB = number of species (connector and non-connector) in partition B of BN (A-B) ; nB_BC = number of species (connector and non-connector) in partition B of BN (B-C); dt= data type (binary= B, weighted= W); tr= data transformation (1= rounded to whole numbers, 2= log transformed and rounded, 3= rescaled and rounded). In A,B,C: De= Defenders, En= Enemies, He= Herbivores, My= Mycorrhizas, Pa1= Parasitoids, Pa2= Parasites, Pl= Plants, Po= Pollinators, Pr= Predators, SD= Seed Dispersers, SP= Seed Predator.

\newpage
## Bipartite networks

```{r}
x1_2= x1[x0$nB_con>6, ]
knitr::kable(x1_2, digits=2)
```

A,B,C= partitions; dt= data type (binary= B, weighted= W); tr= data tranformation (1= rounded to whole numbers, 2= log transformed and rounded, 3= rescaled and rounded); M_AB/M_BC= modularity; pM_AB/pM_BC= P-value of modularity compared to null model; N_AB/N_BC= Nestedness SM; pN_AB/pN_BC= P-value of Nestedness SM compared to null model; T_AB/T_BC = Topology (M= purely modular, C= hierarchical compound). We applied NODF and WNODA to measure nestedness of, respectively, binary and weighted networks.


\newpage
## Tripartite networks

```{r}

x2_2= x2[x0$nB_con>6, ]

knitr::kable(x2_2, digits=2)
```

A,B,C= partitions; S/F= stacked or forked TN; dt= data type (binary= B, weighted= W); tr= data tranformation (1= rounded to whole numbers, 2= log transformed and rounded, 3= rescaled and rounded); C.adj= adjusted congruence; C.r= realized congruence; H= hypermodularity; p1= P-value of adjusted congruence compared to null model 1; p2= P-value of adjusted congruence compared to null model 2. In A,B,C: De= Defenders, En= Enemies, He= Herbivores, My= Mycorrhizas, Pa1= Parasitoids, Pa2= Parasites, Pl= Plants, Po= Pollinators, Pr= Predators, SD= Seed Dispersers, SP= Seed Predator.

# Forked vs. Stacked
## Realized Congruence

```{r}
wilcox.test(x2_2$C.r~x2_2$SF)
```

## Adjusted Congruence
```{r}
wilcox.test(x2_2$C.adj~x2_2$SF)
```

## Hypermodularity
```{r}
wilcox.test(x2_2$H~x2_2$SF)
```

# Mechanism Testing (Mantel tests)

```{r, results='asis'}
load("files_results/Mantel_results.RData")
for(DATASET in 1:length(Manteltests)){
  cat("\\subsection{",toupper(names(Manteltests)[DATASET]),"}")
  cat("\\subsubsection{\\underline{Partition A}}")
  if(!is.null(Manteltests[[DATASET]]$partitionA$TAXON_HM)){
    cat("\\paragraph{Taxonomy x Hypermodules}")
    cat("\\paragraph{}Call: ")
    print(Manteltests[[DATASET]]$partitionA$TAXON_HM$call)
    cat("\\paragraph{}Method: ")
    print(Manteltests[[DATASET]]$partitionA$TAXON_HM$method)
    cat("\\paragraph{}Statistic: ")
    print(Manteltests[[DATASET]]$partitionA$TAXON_HM$statistic)
    cat("\\paragraph{}P-Value: ")
    print(Manteltests[[DATASET]]$partitionA$TAXON_HM$signif)
    cat("\\paragraph{}Permutations: ")
    print(Manteltests[[DATASET]]$partitionA$TAXON_HM$permutations)
  }
  if(!is.null(Manteltests[[DATASET]]$partitionA$DISTR_HM)){
    cat("\\paragraph{Distribution x Hypermodules}")
    cat("\\paragraph{}Call: ")
    print(Manteltests[[DATASET]]$partitionA$DISTR_HM$call)
    cat("\\paragraph{}Method: ")
    print(Manteltests[[DATASET]]$partitionA$DISTR_HM$method)
    cat("\\paragraph{}Statistic: ")
    print(Manteltests[[DATASET]]$partitionA$DISTR_HM$statistic)
    cat("\\paragraph{}P-Value: ")
    print(Manteltests[[DATASET]]$partitionA$DISTR_HM$signif)
    cat("\\paragraph{}Permutations: ")
    print(Manteltests[[DATASET]]$partitionA$DISTR_HM$permutations)
  }
  cat("\\subsubsection{\\underline{Partition B}}")
  if(!is.null(Manteltests[[DATASET]]$partitionB$TAXON_HM)){
    cat("\\paragraph{Taxonomy x Hypermodules}")
    cat("\\paragraph{}Call: ")
    print(Manteltests[[DATASET]]$partitionB$TAXON_HM$call)
    cat("\\paragraph{}Method: ")
    print(Manteltests[[DATASET]]$partitionB$TAXON_HM$method)
    cat("\\paragraph{}Statistic: ")
    print(Manteltests[[DATASET]]$partitionB$TAXON_HM$statistic)
    cat("\\paragraph{}P-Value: ")
    print(Manteltests[[DATASET]]$partitionB$TAXON_HM$signif)
    cat("\\paragraph{}Permutations: ")
    print(Manteltests[[DATASET]]$partitionB$TAXON_HM$permutations)
  }
  if(!is.null(Manteltests[[DATASET]]$partitionB$DISTR_HM)){
    cat("\\paragraph{Distribution x Hypermodules}")
    cat("\\paragraph{}Call: ")
    print(Manteltests[[DATASET]]$partitionB$DISTR_HM$call)
    cat("\\paragraph{}Method: ")
    print(Manteltests[[DATASET]]$partitionB$DISTR_HM$method)
    cat("\\paragraph{}Statistic: ")
    print(Manteltests[[DATASET]]$partitionB$DISTR_HM$statistic)
    cat("\\paragraph{}P-Value: ")
    print(Manteltests[[DATASET]]$partitionB$DISTR_HM$signif)
    cat("\\paragraph{}Permutations: ")
    print(Manteltests[[DATASET]]$partitionB$DISTR_HM$permutations)
  }
  cat("\\subsubsection{\\underline{Partition C}}")
  if(!is.null(Manteltests[[DATASET]]$partitionC$TAXON_HM)){
    cat("\\paragraph{Taxonomy x Hypermodules}")
    cat("\\paragraph{}Call: ")
    print(Manteltests[[DATASET]]$partitionC$TAXON_HM$call)
    cat("\\paragraph{}Method: ")
    print(Manteltests[[DATASET]]$partitionC$TAXON_HM$method)
    cat("\\paragraph{}Statistic: ")
    print(Manteltests[[DATASET]]$partitionC$TAXON_HM$statistic)
    cat("\\paragraph{}P-Value: ")
    print(Manteltests[[DATASET]]$partitionC$TAXON_HM$signif)
    cat("\\paragraph{}Permutations: ")
    print(Manteltests[[DATASET]]$partitionC$TAXON_HM$permutations)
  }
  if(!is.null(Manteltests[[DATASET]]$partitionC$DISTR_HM)){
    cat("\\paragraph{Distribution x Hypermodules}")
    cat("\\paragraph{}Call: ")
    print(Manteltests[[DATASET]]$partitionC$DISTR_HM$call)
    cat("\\paragraph{}Method: ")
    print(Manteltests[[DATASET]]$partitionC$DISTR_HM$method)
    cat("\\paragraph{}Statistic: ")
    print(Manteltests[[DATASET]]$partitionC$DISTR_HM$statistic)
    cat("\\paragraph{}P-Value: ")
    print(Manteltests[[DATASET]]$partitionC$DISTR_HM$signif)
    cat("\\paragraph{}Permutations: ")
    print(Manteltests[[DATASET]]$partitionC$DISTR_HM$permutations)
  }
  }

```